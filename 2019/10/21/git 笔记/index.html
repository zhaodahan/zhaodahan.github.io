<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>git 笔记 | 赵大汉的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GIT 笔记搭建git 仓库环境安装 介绍window系统如何安装下载路径：Git客户端安装后再任意地方鼠标右键就会出现如下，Git Bash Here就是我们的客户端 初次运行 Git 前的配置 安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global">
<meta property="og:type" content="article">
<meta property="og:title" content="git 笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;21&#x2F;git%20%E7%AC%94%E8%AE%B0&#x2F;index.html">
<meta property="og:site_name" content="赵大汉的个人博客">
<meta property="og:description" content="GIT 笔记搭建git 仓库环境安装 介绍window系统如何安装下载路径：Git客户端安装后再任意地方鼠标右键就会出现如下，Git Bash Here就是我们的客户端 初次运行 Git 前的配置 安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12git config --global">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-3982651ccae9e7db.jpg?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-1a5cde2c6ea71d56.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-6aeb26e51005605f.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-d9bcfde50a5da466.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-112ae4b062a87c61.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-685665a710253672.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-0d80be964d7135c8.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-5accf85711b7b292.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-524a65016268ddad.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-c1d5042fa613864f.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-5bfe6947e56d4a2d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-7e0ed5643b7aa8d1.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-f2c5b58dd9f84984.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-e80c37e983c6d767.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-f7a205ed6544928d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-c145bf0d470028f1.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-868697247dc73377.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-3ef4b4c68ac59fc3.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-cb227be3056bb420.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-ef35a27e51d1aa79.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-81b2cf09cb0864cd.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-ff3132a249f75a4d.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-c90584783b25ac0e.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-9719d401f79eaaaf.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-9b660579cc6e278e.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-df44d8ab88e2d689.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-c6024a4ed9be32d9.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-a41980f19a5678ab.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-ecfd58b1f7f210ab.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-04948eecdf6b242a.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-38954d1eb68b8290.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;695731&#x2F;201510&#x2F;695731-20151017164205272-1808101337.png">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-001ac894906d8774.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-6ff4670ad502150b.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-a629d477d591a4a1.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-0d7ad0d8544da200.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-fa678152e9802a60.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-97c77a6276683ce9.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-aa84d207701f2512.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-e4c6f8c207329c4c.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-c94e858c56ce2210.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-810ca5d1d4a7053b.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-cd090e0cf304f589.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-193cae7fdc059f35.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-97fedcc803fd5c85.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-ab5eed0ea0e7ed7c.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-817d9661d25c84fb.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-f90f9d9c8d628f31.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-3e73d2a880a707b3.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-dbf7ee2243ed5ee7.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-02ceb2dc99ad3291.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-0d55d26667bbd33a.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-51a07e8355c4bd03.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;zhaodahan&#x2F;zhao_Note&#x2F;blob&#x2F;master&#x2F;wiki_img&#x2F;github_delete.png?raw=true">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;zhaodahan&#x2F;zhao_Note&#x2F;blob&#x2F;master&#x2F;wiki_img&#x2F;github_delete2.png?raw=true">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;114186&#x2F;201706&#x2F;114186-20170623062535695-2077512996.png">
<meta property="og:updated_time" content="2018-12-24T11:43:57.537Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;1637925-3982651ccae9e7db.jpg?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240">
  
    <link rel="alternate" href="/atom.xml" title="赵大汉的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">赵大汉的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">dahan&#39;s Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-git 笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/21/git%20%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2019-10-21T13:41:06.006Z" itemprop="datePublished">2019-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      git 笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="GIT-笔记"><a href="#GIT-笔记" class="headerlink" title="GIT 笔记"></a>GIT 笔记</h1><h1 id="搭建git-仓库"><a href="#搭建git-仓库" class="headerlink" title="搭建git 仓库"></a>搭建git 仓库</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><hr>
<p>介绍window系统如何安装<br>下载路径：<a href="http://git-scm.com/download" target="_blank" rel="noopener">Git客户端</a><br>安装后再任意地方鼠标右键就会出现如下，<code>Git Bash Here</code>就是我们的客户端<br><a href="http://upload-images.jianshu.io/upload_images/1637925-3982651ccae9e7db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-3982651ccae9e7db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br><a href="http://upload-images.jianshu.io/upload_images/1637925-1a5cde2c6ea71d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-1a5cde2c6ea71d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h2 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h2><hr>
<p>安装完<code>Git</code>应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个<code>Git</code>的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;zhaodahan&quot;</span><br><span class="line">git config --global user.email 1791154630@qq.com</span><br></pre></td></tr></table></figure>

<p>再次强调，使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><hr>
<p>指定一个目录作为你的仓库地址，如使用<code>E:\gitRepository</code>作为后期所有项目的总空间。<br>创建我的第一个项目名~起名叫做<code>gitDemo</code>，这个直接在window新建一个文件夹就行。<br>然后在<code>gitDemo</code>目录里面，右键鼠标打开<code>git</code>客户端，输入创建版本库命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-6aeb26e51005605f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-6aeb26e51005605f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>这样仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个<code>.git</code>的目录(建议隐藏的)，这个目录是<code>Git</code>来跟踪管理版本库的，不要手动修改这个目录里面的文件，否则就把Git仓库给破坏了。</p>
<h2 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h2><hr>
<p><code>git</code>仓库搭建好了，现在就来添加文件到版本库里面。<br>创建一个<code>txt</code>文档起名叫做<code>readme.txt</code>，往里面添加一点内容<code>hello git</code>.<br>注意，最好不要用系统自带的<code>txt</code>来编写，因为这里需要文件是<code>UTF-8</code>格式的，所以我使用<code>EditPlus</code>这种可以把文件另存为<code>UTF-8</code>格式的编辑器的。<br>创建好文件后，添加到仓库只需要2个操作：<br>第一步，用命令<code>git add</code>告诉<code>Git</code>，把本地代码托送到暂存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-d9bcfde50a5da466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-d9bcfde50a5da466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>第二步，用命令<code>git commit</code>告诉<code>Git</code>，把文件提交到仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>



<p><a href="http://upload-images.jianshu.io/upload_images/1637925-112ae4b062a87c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-112ae4b062a87c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p><code>-m</code> 参数是用来注释你提交的信息的，这样以后才知道这次提交时用来干嘛</p>
<p>或者你嫌弃文件太多，一次次add感觉很麻烦，那么可以试试使用<code>git add .</code>提交，<code>.</code>表示提交当前目录所有文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add . </span><br><span class="line">或者</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure>

<h2 id="查看当前新增或者修改的文件"><a href="#查看当前新增或者修改的文件" class="headerlink" title="查看当前新增或者修改的文件"></a>查看当前新增或者修改的文件</h2><hr>
<p>实际使用中你不止只有一个文件，或新增或修改多个文件，可能时间一久就忘了有多少文件需要提交<br>这里模拟一下，首先新建一个<code>hello.txt</code>的文件，然后修改<code>readme.txt</code>内容，添加一句<code>come on baby</code>.<br>这样就有2个文件需要提交了。<br>我们使用<code>git status</code>命令来查看当前状态,是否有未提交的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-685665a710253672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-685665a710253672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>如图，可以看到红色的字体显示的一个<code>readme.txt</code>被修改过了，但还没有准备提交的修改，另外一个是<code>Untracked files: hello.txt</code>，表示新增的文件。</p>
<p>这时候准备把上面2个文件都提交，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git add hello.txt</span><br></pre></td></tr></table></figure>

<p>提交后再使用<code>git status</code>命令查看下<br><a href="http://upload-images.jianshu.io/upload_images/1637925-0d80be964d7135c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-0d80be964d7135c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>你会看到这2个文件都变成绿色了，表示添加到暂存区成功了<br>然后使用<code>git commit</code>提交后，在使用<code>git status</code>查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;second commit&quot;</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-5accf85711b7b292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-5accf85711b7b292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>如图，可以看到文件提交到仓库了，并且<code>git status</code>后提示<code>nothing to commit, working directory clean</code>，说明当前没有需要提交的修改，工作目录是干净。</p>
<h2 id="比较当前文件跟版本文件内容"><a href="#比较当前文件跟版本文件内容" class="headerlink" title="比较当前文件跟版本文件内容"></a>比较当前文件跟版本文件内容</h2><hr>
<p>假如你已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff readme.txt</span><br></pre></td></tr></table></figure>

<p>发现什么反应都没有。</p>
<p>原来是<code>readme.txt</code>已经<code>commit</code>提交到版本库了。内容一样当然没有啥好比对的。这里我们往<code>readme.txt</code>添加一条内容<code>day day up</code>。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-524a65016268ddad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-524a65016268ddad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>如图，最后一行绿色的<code>+day day up.</code>表示是新增的。</p>
<h2 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h2><hr>
<p>有时候你想看看之前提交的历史纪录~那么就需要使用到<code>git log</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-c1d5042fa613864f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-c1d5042fa613864f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>如图，可以看到我们提交的2次历史，<code>first commit</code>和<code>second commit</code>。历史纪录是根据时间倒叙排列的。<br>如果觉得代码太多了，加点过滤就行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-5bfe6947e56d4a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-5bfe6947e56d4a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>其中，里面那一串常常字符串作用很重要，是用于版本回退的</p>
<h1 id="理解git暂存区"><a href="#理解git暂存区" class="headerlink" title="理解git暂存区"></a>理解git暂存区</h1><p>暂存区，在<code>git</code>中是个很重要的概念，弄懂了暂存区才算真正懂了<code>git</code></p>
<h2 id="什么是暂存区"><a href="#什么是暂存区" class="headerlink" title="什么是暂存区"></a>什么是暂存区</h2><hr>
<p>工作区： 我们正在编辑的区域</p>
<p>暂存区： 执行了add 操作后的区域</p>
<p>版本库 ：执行了commit之后的 (这里还要有区别，这个版本库，包含了本地版本库的和远程版本库的内容，push 后就是同步本地与远程的版本库)</p>
<hr>
<p>下图展示了工作区、版本库中的暂存区和版本库之间的关系。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-7e0ed5643b7aa8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-7e0ed5643b7aa8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>图中可以看到 <code>Git</code>命令是如何影响工作区和暂存区<code>（stage, index）</code>的。</p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在<strong>版本库中标记为 <code>index</code> 的区域是暂存区</strong><code>（stage, index）</code>，标记为 <code>master</code> 的是 <code>master</code> 分支所代表的目录树。</li>
<li>图中我们可以看出此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”。所以图示的命令中出现<code>HEAD</code>的地方可以用<code>master</code>来替换。</li>
<li>图中的<code>objects</code>标识的区域为<code>Git</code>的对象库，实际位于<code>.git/objects</code>目录下。</li>
<li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区index的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的<code>ID</code> 被记录在暂存区的文件索引中。</li>
<li>当执行提交操作<code>（git commit）</code>时，暂存区的目录树写到版本库（对象库）中，<code>master</code>分支会做相应的更新。即<code>master</code>指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git checkout .</code> 或者 <code>git checkout -- [file]</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li>
<li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD [file]</code> 命令时，会用 <code>HEAD</code> 指向的 <code>master</code> 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
<li>当执行 <code>git rm --cached [file]</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git rm file</code>命令时，会同时删除暂存区和工作区的文件。</li>
<li>当执行 <code>rm file</code>命令时，只会删除工作区的文件。</li>
</ul>
<hr>
<h2 id="举例子来证明以上观点"><a href="#举例子来证明以上观点" class="headerlink" title="举例子来证明以上观点"></a>举例子来证明以上观点</h2><hr>
<p>假设：<br>工作区：a<br>暂存区（index）:b<br>HEAD:C</p>
<p>git diff命令结论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff           比较a跟b</span><br><span class="line">git diff --cached  比较b跟c</span><br><span class="line">git diff HEAD      比较a跟c</span><br></pre></td></tr></table></figure>

<p>git reset跟 git checkout结论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD              c覆盖b</span><br><span class="line">git checkout -- &lt;file&gt;      b覆盖a</span><br><span class="line">git checkout HEAD &lt;file&gt;    c覆盖a,b</span><br></pre></td></tr></table></figure>

<p>git rm命令结论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm          删除a跟b</span><br><span class="line">git rm --cached 只删除b</span><br><span class="line">rm file         只删除a</span><br></pre></td></tr></table></figure>

<h2 id="证明git-diff结论"><a href="#证明git-diff结论" class="headerlink" title="证明git diff结论"></a>证明git diff结论</h2><hr>
<p>例子，默认新建一个<code>readme.txt</code>，里面输入内容<code>one</code>然后add并且<code>commit</code>一次。</p>
<p>1：修改<code>readme.txt</code>，新增内容<code>two</code>，这时候a内容改变了,多了<code>two</code>，而b跟c内容不变，都只有<code>one</code>。<br>执行<code>git diff readme.txt</code>查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-f2c5b58dd9f84984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-f2c5b58dd9f84984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论：如图看出，内容有修改， a跟b比较了</p>
<hr>
<p>执行<code>git diff --cached readme.txt</code>查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-e80c37e983c6d767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-e80c37e983c6d767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论：如图看出，没有变化，因为b跟c内容一样。</p>
<hr>
<p>执行<code>git diff HEAD readme.txt</code>查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-f7a205ed6544928d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-f7a205ed6544928d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>如图所示：内容有修改，a跟c比较了</p>
<hr>
<p>2.这时候执行<code>git add readme.txt</code>,这时候a，b内容都多了two，而c内容不变，只有<code>one</code><br>执行<code>git diff readme.txt</code>查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-c145bf0d470028f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-c145bf0d470028f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论：如图看出，没有变化， 因为a跟b内容一样。</p>
<hr>
<p>执行git diff –cached readme.txt查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-868697247dc73377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-868697247dc73377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论：如图看出，内容有修改，b跟c比较了</p>
<hr>
<p>执行<code>git diff HEAD readme.txt</code>查看效果</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-3ef4b4c68ac59fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-3ef4b4c68ac59fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论：如图看出，内容有修改，a跟c比较了</p>
<p>3.最后使用<code>git commit</code>提交一次，这时候a,b,c内容都一样，都包含<code>two</code>。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-cb227be3056bb420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-cb227be3056bb420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>结论，如图看出，没有变化，说明a,b,c内容一样</p>
<hr>
<p>根据上面的实例再一次证明了如下观点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff           比较工作区跟暂存区</span><br><span class="line">git diff --cached  比较暂存区跟HEAD</span><br><span class="line">git diff HEAD      比较工作区跟HEAD</span><br></pre></td></tr></table></figure>



<h2 id="证明git-reset跟-git-checkout结论"><a href="#证明git-reset跟-git-checkout结论" class="headerlink" title="证明git reset跟 git checkout结论"></a>证明git reset跟 git checkout结论</h2><hr>
<p>例子，默认新建一个<code>readme.txt</code>，里面输入内容<code>one</code>然后add并且<code>commit</code>一次，这时候a,b,c内容都是<code>one</code></p>
<hr>
<p>1.修改<code>readme.txt</code>，新增内容<code>two</code>，执行<code>git add readme.txt</code>操作，这时候a ,b内容都多了<code>two</code>,c还是只有<code>one</code>.<br>执行<code>git reset HEAD -- readme.txt</code>命令后，c覆盖b,这时候b内容也变成只有<code>one</code>了，使用<code>git diff readme.txt</code>命令可以看到，有内容修改，a跟b内容不一样。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-ef35a27e51d1aa79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-ef35a27e51d1aa79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<p>2.此时a内容有two,b和c都只有one，执行<code>git checkout -- readme.txt</code>后，b覆盖a,此时a,b,c都是one。执行<code>git diff readme.txt</code>命令可以看到，没有改变。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-81b2cf09cb0864cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-81b2cf09cb0864cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<p>3.此时a,b,c都只有<code>one</code>，修改一下，添加内容<code>two</code>，执行<code>git add readme.txt</code>和<code>git commit -m &quot;two&quot;</code>.再修改一次<code>readme.txt</code>,添加内容<code>three</code>,然后会执行<code>git add readme.txt</code>，此时a跟b都包含three，而c只包含one跟two。执行<code>git checkout HEAD readme.txt</code>后，c覆盖a和b,a,b里面内容都只有one跟two。分别使用命令<code>git diff --cached</code>和<code>git diff HEAD</code>来查看b跟c，a跟c的比对，发现都一样。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-ff3132a249f75a4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-ff3132a249f75a4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<p>根据上面的实例再一次证明了如下观点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD              HEAD覆盖暂存区</span><br><span class="line">git checkout -- &lt;file&gt;      暂存区覆盖工作区</span><br><span class="line">git checkout HEAD &lt;file&gt;    HEAD覆盖暂存区和工作区</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="证明git-rm-结论"><a href="#证明git-rm-结论" class="headerlink" title="证明git rm 结论"></a>证明git rm 结论</h2><hr>
<p>默认新建一个<code>readme.txt</code>，里面输入内容<code>one</code>，然后使用<code>git add readme.txt</code>命令。<br>1.执行git rm readme.txt命令，发现文件被删除了。</p>
<p>2.再新建一个一个<code>readme.txt</code>，里面输入内容 one，然后使用<code>git add readme.txt</code>命令。执行<code>git rm --cached readme.txt</code>命令，发现文件内<code>readme.txt</code>还在，然后执行<code>git status</code>命令，发现是<code>Untracked</code>状态，也就是未<code>add</code>，这就说明暂存区被删除了。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-c90584783b25ac0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-c90584783b25ac0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<p>根据上面的实例再一次证明了如下观点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file      会将文件从缓存区和你的硬盘中（工作区）删除</span><br><span class="line">git rm --cached  只删除暂存区，不删除工作区</span><br><span class="line">rm file          只删除工作区</span><br></pre></td></tr></table></figure>

<h1 id="提交错了我想撤销或者回退版本"><a href="#提交错了我想撤销或者回退版本" class="headerlink" title="提交错了我想撤销或者回退版本"></a>提交错了我想撤销或者回退版本</h1><p>这几个功能正式体现版本控制工具的强大之处。(十分好用)</p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>如果你文件<strong>只是在工作区修改</strong>了，但是还没提交到暂存区的时候,回滚就是从暂存区覆盖到工作区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- [file]  b覆盖a</span><br></pre></td></tr></table></figure>

<p>你可以用<code>git checkout -- [file]</code>来撤销。简单的说就是暂存区覆盖工作区。这里模拟一下，比如现在<code>readme.txt</code>里面内容是<code>first day</code>，并且已经提交到暂存区了，此时修改<code>readme.txt</code>，内容改成<code>second day.</code>，然后执行<code>git checkout -- readme.txt</code>命令,你会发现<code>readme.txt</code>内容又变成<code>first day</code>了<br><a href="http://upload-images.jianshu.io/upload_images/1637925-9719d401f79eaaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-9719d401f79eaaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" img"></a></p>
<p>如果你文件<strong>在工作区修改了  ,并且也执行<code>git add</code>命令提交给暂存区</strong>了，那么执行上面的<code>git checkout -- [file]</code>已经无效了，因为两者内容一致。 这时候就需要版本库的内存覆盖缓存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD  c覆盖b</span><br></pre></td></tr></table></figure>

<p>这时候就应该使用<code>git reset HEAD</code>命令来撤销，简单的说就是让<code>HEAD</code>覆盖暂存区，因为此时的<code>HEAD</code>这边的文件内容还是上次提交时的内容。现在模拟一下，现在有<code>readme.txt</code>跟<code>hello.txt</code>两个文件，都经过修改<br><a href="http://upload-images.jianshu.io/upload_images/1637925-9b660579cc6e278e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-9b660579cc6e278e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>如图可以看到，使用<code>git status -s</code>来查看的时候，红色的M表示这2个文件都经过修改，使用<code>git add .</code>提交后在查看，发现都是绿色的M，表示都提交到暂存区了，这时候执行<code>git reset HEAD hello.txt</code>后再查看，发现<code>hello.txt</code>变成红色M了，说明hello.txt从暂存区撤销了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD [file]</span><br></pre></td></tr></table></figure>

<p><code>git checkout HEAD [file]</code>命令是<code>git checkout -- [file]</code>和<code>git reset HEAD</code>的合成体，直接用HEAD覆盖工作区,暂存区。如下图中所示，一开始 工作区暂存区以及HEAD中文件内容都是<code>first day.</code>,此时修改<code>readme.txt</code>内容为<code>second day.</code>，然后执行<code>git add .</code>提交到暂存区，接着执行<code>git checkout HEAD readme.txt</code>命令，再查看<code>readme.txt</code>内容的时候你会发现变成了<code>first day.</code><br><a href="http://upload-images.jianshu.io/upload_images/1637925-df44d8ab88e2d689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-df44d8ab88e2d689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h2 id="版本回退以及切换"><a href="#版本回退以及切换" class="headerlink" title="版本回退以及切换"></a>版本回退以及切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  （这个命令用于C覆盖b比较好用） 这个命令使用来移动 HEAD 指针的</span><br></pre></td></tr></table></figure>

<p>首先，<code>Git</code>必须知道当前版本是哪个版本，在<code>Git</code>中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628164...882e1e0</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。<br>先查看当前版本记录  <code>git log --oneline</code>，发现最近的两个版本为<code>b520a36 第一次提交</code>和<code>479c6fd 第二次提交</code><br><a href="http://upload-images.jianshu.io/upload_images/1637925-c6024a4ed9be32d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-c6024a4ed9be32d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>当前版本是<code>b520a36 第一次提交</code>,现在我们来执行<code>git reset --hard HEAD^</code>来回退到<code>479c6fd 第二次提交</code>版本,如图：<br><a href="http://upload-images.jianshu.io/upload_images/1637925-a41980f19a5678ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-a41980f19a5678ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>

<p>如果你回退版本后又后悔了，想恢复最后那个版本怎么办，通过<code>git reset --hard commit_id</code>命令可以搞定，注意这里的<code>commit_id</code>是版本号，只要记得版本号，你想切换到哪个版本都行，如果你忘记了刚才最后一个的版本号，可以通过<code>git reflog</code>来查看，这里我们记得最后那次版本号为<code>b520a36</code>，执行<code>git reset --hard b520a36</code><br><a href="http://upload-images.jianshu.io/upload_images/1637925-ecfd58b1f7f210ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-ecfd58b1f7f210ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><hr>
<p>这里介绍一下<code>git</code>中的删除操作命令，以及意外删除了该如何还原。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm</span><br></pre></td></tr></table></figure>

<p>执行<code>git rm</code>命令会同时删除工作区跟暂存区中的指定文件，要慎重处理。</p>
<p>但是如果你意外删除了也是可以恢复的。不过要分成2种情况处理：</p>
<ol>
<li><p>还未执行<code>git commit</code>提交到<code>HEAD</code>的时候删除文件，这时候直接使用<code>git checkout HEAD [file]</code>就能还原。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-04948eecdf6b242a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-04948eecdf6b242a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
</li>
<li><p>执行<code>git commit</code>提交到<code>HAED</code>后时候才删除文件，这时候就只能执行<code>git reset --hard HEAD^</code>回退上一个版本。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-38954d1eb68b8290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-38954d1eb68b8290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
</li>
</ol>
<hr>
<h3 id="删除错误提交的commit"><a href="#删除错误提交的commit" class="headerlink" title="删除错误提交的commit"></a>删除错误提交的commit</h3><p>​    有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。</p>
<p>​    <strong>错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的</strong>，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。</p>
<p>​    这个时候，我们必须撤销版本库的修改才能解决问题！</p>
<p>​    git reset有三个选项，–hard、–mixed、–soft。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span><br><span class="line">git reset --soft 版本库ID</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span><br><span class="line">git reset --mixed 版本库ID</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span><br><span class="line">git reset --hard 版本库ID</span><br></pre></td></tr></table></figure>

<p>​    那我们到底应该用哪个选项好呢？</p>
<p>​    （1）如果你是在提交了后，对工作区的代码做了修改，并且想保留这些修改，那么可以使用git reset –mixed 版本库ID，注意这个版本库ID应该不是你刚刚提交的版本库ID，而是<strong>刚刚提交版本库的上一个版本库</strong>。如下图：</p>
<p>​    （2）如果不想保留这些修改，可以直接使用彻底的恢复命令，git reset –hard 版本库ID。</p>
<p>​    （3）为什么不使用–soft呢，因为它只是恢复了版本库，<strong>暂存区仍然存在你错误提交的文件索引</strong>，还需要进一步使用上一节的删除错误添加到暂存区的文件，详细见上文。</p>
<p><img src="https://images2015.cnblogs.com/blog/695731/201510/695731-20151017164205272-1808101337.png" alt="img"></p>
<hr>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><hr>
<p>总结一下上面所学的：</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用<code>git reset --hard HEAD^</code>。</p>
<h1 id="连接远程仓库（github，coding）"><a href="#连接远程仓库（github，coding）" class="headerlink" title="连接远程仓库（github，coding）"></a>连接远程仓库（github，coding）</h1><p>Git尝试连接远程仓库了，目前国内外比较出名的提供<code>Git</code>仓库远程托管的有国外的<code>github</code>，国内的<code>开源中国</code>以及<code>coding</code>。这里以<code>coding</code>为例子介绍如何操作远程仓库。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<p>假如你现在本地有一个<code>gitLearn</code>的项目，想托管到<code>coding</code>上面，那么你先进入<code>coding</code>创建一个仓库，如图。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-001ac894906d8774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-001ac894906d8774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br><a href="http://upload-images.jianshu.io/upload_images/1637925-6ff4670ad502150b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-6ff4670ad502150b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>创建完后复制远程仓库的SSH方式的地址。</p>
<h3 id="连接远仓库命令"><a href="#连接远仓库命令" class="headerlink" title="连接远仓库命令"></a>连接远仓库命令</h3><hr>
<p>现进入本地<code>gitLearn</code>的目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>初始化你的项目，然后提交你的代码到本地库，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m &quot;first submit&quot;</span><br></pre></td></tr></table></figure>

<p>此时你的代码已经在本地库了，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git.coding.net:tengj/gitLearn.git</span><br></pre></td></tr></table></figure>

<p>就连上了远程的<code>gitLearn</code>项目。远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<h3 id="列出远端别名"><a href="#列出远端别名" class="headerlink" title="列出远端别名"></a>列出远端别名</h3><hr>
<p>我们可以使用<code>git remote</code>来列出远端别名，如果没有任何参数，<code>Git</code>会列出它存储的远端仓库别名了事。默认情况下，如果你的项目是克隆的（与本地创建一个新的相反）， <code>Git</code>会自动将你的项目克隆自的仓库添加到列表中，并取名“<code>origin</code>”。 如果你执行时加上 <code>-v</code> 参数，你还可以看到每个别名的实际链接地址。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-a629d477d591a4a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-a629d477d591a4a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h3 id="推送内容到远程库"><a href="#推送内容到远程库" class="headerlink" title="推送内容到远程库"></a>推送内容到远程库</h3><hr>
<p>连上之后就可以推送代码到远程仓库了，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-0d7ad0d8544da200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-0d7ad0d8544da200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>由于<strong>远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数</strong>，<code>Git</code>不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，直接用<code>git push origin master</code>。 （还有一种就是直接clone 远程仓库，做操作）<br>推送完后，可以查看远程仓库上多了<code>readme.txt</code>文件。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-fa678152e9802a60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-fa678152e9802a60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>如果你使用上面命令出现如下错误提示：</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-97c77a6276683ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-97c77a6276683ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>那是因为你<code>HEAD</code>区域还是空的，记得先用<code>git add</code>和<code>git commit</code>命令提交你想提交的文件到<code>HEAD</code>。然后在用<code>git push -u origin master</code>就可以了。</p>
<h3 id="从远程仓库下载项目到本地"><a href="#从远程仓库下载项目到本地" class="headerlink" title="从远程仓库下载项目到本地"></a>从远程仓库下载项目到本地</h3><hr>
<p>用<code>git clone</code><br>比如我想在我电脑<code>E:\gitRepository</code>目录下面下载这个远程仓库项目<br>直接使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@git.coding.net:tengj/gitLearn.git</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-aa84d207701f2512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-aa84d207701f2512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>就会下载项目到<code>E:\gitRepository</code>下面。</p>
<h3 id="从远端仓库提取数据并尝试合并到当前分支"><a href="#从远端仓库提取数据并尝试合并到当前分支" class="headerlink" title="从远端仓库提取数据并尝试合并到当前分支"></a>从远端仓库提取数据并尝试合并到当前分支</h3><hr>
<p>如果你跟别人一起连着一个远程仓库项目，别人提交了代码，你想更新成最新的代码怎么办。<br>使用<code>git pull</code>命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-e4c6f8c207329c4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-e4c6f8c207329c4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h3 id="删除跟远程仓库的连接"><a href="#删除跟远程仓库的连接" class="headerlink" title="删除跟远程仓库的连接"></a>删除跟远程仓库的连接</h3><hr>
<p>如果你需要删除一个远端 —— 不再需要它了、项目已经没了，等等 —— 你可以使用 <code>git remote rm [alias]</code> 把它删掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">// 这里只是和远程仓库断开连接，并没有在远程将库删除。</span><br></pre></td></tr></table></figure>

<p>注意，断开跟远程的连接后，如果还想连上，则需要再来一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git.coding.net:tengj/gitLearn.git</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote               查看远程库的信息  </span><br><span class="line">git remote -v            显示更详细的信息  </span><br><span class="line">git remote add origin git@git.coding.net:tengj/gitLearn.git  连接远程仓库  </span><br><span class="line">git clone git@git.coding.net:tengj/gitLearn.git            复制一份远程仓库项目到本地  </span><br><span class="line">git remote rm origin     关闭连接远程仓库  </span><br><span class="line">git push origin master   推送分支  </span><br><span class="line">git pull origin master   抓取更新</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="多人协同工作之分支管理"><a href="#多人协同工作之分支管理" class="headerlink" title="多人协同工作之分支管理"></a>多人协同工作之分支管理</h1><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><hr>
<p>分支就像是电影里面的平行宇宙。</p>
<p>当你正在电脑前努力学习<code>Git</code>的时候，另一个你正在另一个平行宇宙里努力学习<code>SVN</code>。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了<code>Git</code>又学会了<code>SVN</code>！<br><a href="http://upload-images.jianshu.io/upload_images/1637925-c94e858c56ce2210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-c94e858c56ce2210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<p>为了真正理解 <code>Git</code> 处理分支的方式，需要清楚<code>Git</code>是如何保存数据的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</span><br></pre></td></tr></table></figure>

<p>在进行提交操作时，<code>Git</code>会保存一个提交对象（<code>commit object</code>）。根据<code>Git</code>保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p>
<p><code>Git</code>的分支，其实本质上仅仅是指向提交对象的可变指针。 <code>Git</code>的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<blockquote>
<p><code>Git</code> 的 “master” 分支并不是一个特殊分支。它就跟其它分支完全没有区别。 之所以几乎每一个仓库&gt; 都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<br>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。<br>但<code>Git</code>的分支是与众不同的，无论创建、切换和删除分支，<code>Git</code>在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><hr>
<p><code>Git</code>是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的<strong>指针</strong>。 比如，创建一个 <code>testing</code>分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>

<p>这会在当前所在的提交对象上创建一个指针。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-810ca5d1d4a7053b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-810ca5d1d4a7053b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个指向相同提交历史的分支。"></a></p>
<p>那么，<code>Git</code>又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。在 <code>Git</code>中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在<code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-cd090e0cf304f589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-cd090e0cf304f589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HEAD 指向当前所在的分支."></a></p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>

<p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><hr>
<p>要切换到一个已存在的分支，你需要使用<code>git checkout</code>命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>

<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-193cae7fdc059f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-193cae7fdc059f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HEAD 指向当前所在的分支."></a></p>
<p>上面的创建分支和切换分支命令可以合起来用下面这个命令来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b testing</span><br></pre></td></tr></table></figure>

<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-97fedcc803fd5c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-97fedcc803fd5c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HEAD 分支随着提交操作自动向前移动."></a><br>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code>时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-ab5eed0ea0e7ed7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-ab5eed0ea0e7ed7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检出时 HEAD 随之移动."></a><br>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略<code>testing</code>分支所做的修改，以便于向另一个方向进行开发。<br>可以使用 <code>git branch</code>命令查看当前分支，注意前面带<code>*</code>的表示当前分支<br><a href="http://upload-images.jianshu.io/upload_images/1637925-817d9661d25c84fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-817d9661d25c84fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<hr>
<blockquote>
<p><strong>Note</strong><br><strong>分支切换会改变你工作目录中的文件</strong><br>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目&gt; 录会恢复到该分支最后一次提交时的样子。 如果<code>Git</code>不能干净利落地完成这个任务，它将禁止切换分支。</p>
</blockquote>
<h3 id="合并分支（快速合并）"><a href="#合并分支（快速合并）" class="headerlink" title="合并分支（快速合并）"></a>合并分支（快速合并）</h3><hr>
<p>假如我们在<code>testing</code>上的工作完成了，就可以把<code>testing</code>合并到<code>master</code>上。<code>Git</code>怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>testing</code>的当前提交，就完成了合并，这里你需要使用<code>git merge</code>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge testing</span><br><span class="line">Updating 64ba18a..760118b</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看内容，就可以看到，和<code>testing</code>分支的最新提交是完全一样的。<br>注意到上面的<code>Fast-forward</code>信息，<code>Git</code>告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>testing</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。<br><a href="http://upload-images.jianshu.io/upload_images/1637925-f90f9d9c8d628f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-f90f9d9c8d628f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><hr>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支,这里需要使用<code>git branch -d</code>命令来删除分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">Deleted branch testing (was 760118b).</span><br></pre></td></tr></table></figure>

<p><a href="http://upload-images.jianshu.io/upload_images/1637925-3e73d2a880a707b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-3e73d2a880a707b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h3 id="分支合并冲突"><a href="#分支合并冲突" class="headerlink" title="分支合并冲突"></a>分支合并冲突</h3><hr>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。<br>准备新的<code>dev</code>分支，继续我们的新分支开发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>

<p>修改<code>README.md</code>内容，添加一样内容”day day up~”，在<code>dev</code>分支上提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &quot;one commit&quot;</span><br><span class="line">[dev 6a6a08e] one commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br></pre></td></tr></table></figure>

<p><code>Git</code>还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。<br>在<code>master</code>分支上把<code>README.md</code>文件的最后改为 <code>good good study</code>,然后提价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &quot;two commit&quot;</span><br><span class="line">[master 75d6f25] two commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>dev</code>分支各自都分别有新的提交，变成了这样：<br><a href="http://upload-images.jianshu.io/upload_images/1637925-dbf7ee2243ed5ee7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-dbf7ee2243ed5ee7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a><br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>果然冲突了！Git告诉我们， README.md文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">​```  </span><br><span class="line">我们可以直接查看`README.md`的内容：  </span><br><span class="line">​``` bash</span><br><span class="line">$ cat README.md</span><br><span class="line">#gitLearn</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">good good study</span><br><span class="line">=======</span><br><span class="line">day day up</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></pre></td></tr></table></figure>



<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#gitLearn</span><br><span class="line">good good study</span><br><span class="line">day day up</span><br></pre></td></tr></table></figure>

<p>再提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;merge commit&apos;</span><br><span class="line">[master 9a4d00b] merge commit</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>dev</code>分支变成了下图所示：</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-02ceb2dc99ad3291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-02ceb2dc99ad3291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   9a4d00b merge commit</span><br><span class="line">|\</span><br><span class="line">| * 6a6a08e one commit</span><br><span class="line">* | 75d6f25 two commit</span><br><span class="line">|/</span><br><span class="line">* ae06dcf 123</span><br><span class="line">* 760118b test</span><br><span class="line">*   64ba18a test</span><br><span class="line">|\</span><br><span class="line">| *   4392848 Accept Merge Request #1 test : (dev -&gt; master)</span><br><span class="line">| |\</span><br><span class="line">| | * a430c4b update README.md</span><br><span class="line">| |/</span><br><span class="line">| * 88ec6d7 Initial commit</span><br><span class="line">* 32d11c8 update README.md</span><br><span class="line">* 8d5acc1 new file README</span><br><span class="line">* e02f115 Initial commit</span><br><span class="line"></span><br><span class="line">​```  </span><br><span class="line">最后，删除`feature1`分支：  </span><br><span class="line">​``` bash</span><br><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 6a6a08e).</span><br></pre></td></tr></table></figure>



<h3 id="合并分支（普通合并）"><a href="#合并分支（普通合并）" class="headerlink" title="合并分支（普通合并）"></a>合并分支（普通合并）</h3><hr>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用<code>Fast forward</code>模式，<code>Git</code>就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。<br>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：<br>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure>

<p>修改README.md文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;submit&apos;</span><br><span class="line">[dev fee6025] submit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>

<p>目前来说流程图是这样：</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-0d55d26667bbd33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-0d55d26667bbd33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   b98f802 merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * fee6025 submit</span><br><span class="line">|/</span><br><span class="line">*   9a4d00b merge commit</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：<br><a href="http://upload-images.jianshu.io/upload_images/1637925-51a07e8355c4bd03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-51a07e8355c4bd03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><hr>
<p>开发的时候一般3个分支就可以了：</p>
<ol>
<li>mster 主分支用来发布</li>
<li>dev 日常开发用的分支</li>
<li>bug 修改bug用的分支</li>
</ol>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本,你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了；<br><code>bug</code>分支用来处理日常bug,搞定后合到dev分支即可；</p>
<p>假设远程公共仓库，有一个<code>master</code>和一个<code>dev</code>分支，进行多人协作开发时候（每个人的公钥必须加入到远程账号下，否则无法<code>push</code>）， 每个人都应该<code>clone</code>一份到本地。 但是<code>clone</code>的只是<code>master</code>，如果远程的<code>master</code>和<code>dev</code>一样，没关系；如果不一致，则需要<code>clone</code>出<code>dev</code>分支 <code>git checkout -b dev origin/dev</code> 之后每个人在本地的<code>dev</code>分支上独自开发（最好不要在<code>mast</code>上开发）， 开发完成之后<code>push</code>到远程<code>dev</code>, <code>git push origin dev</code>。 之后审核人再确定是否合并<code>dev</code>到<code>master</code>。</p>
<h3 id="团队多人开发协作"><a href="#团队多人开发协作" class="headerlink" title="团队多人开发协作"></a>团队多人开发协作</h3><hr>
<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。<br>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@git.coding.net:tengj/gitLearn.git (fetch)</span><br><span class="line">origin  git@git.coding.net:tengj/gitLearn.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><hr>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，<code>Git</code>就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>

<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><hr>
<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。<br>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把<code>SSH Key</code>添加到<code>GitHub</code>）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@git.coding.net:tengj/gitStudy.git</span><br><span class="line">Cloning into &apos;gitStudy&apos;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">​```  </span><br><span class="line">当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的`master`分支。不信可以用`git branch`命令看看：</span><br><span class="line">​``` bash</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支（程分支dev要先创建）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">git</span><br></pre></td></tr></table></figure>

<p>创建dev分之后，先同步远程服务器上的数据到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">From git.coding.net:tengj/gitStudy</span><br><span class="line"> * [new branch]      dev        -&gt; origin/dev</span><br></pre></td></tr></table></figure>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &apos;test&apos;</span><br><span class="line">[dev c120ad6] test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 262 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@git.coding.net:tengj/gitStudy.git</span><br><span class="line">   65c05aa..c120ad6  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br><span class="line">To git@git.coding.net:tengj/gitStudy.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;git@git.coding.net:tengj/gitStudy.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，<strong>先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin dev</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From git.coding.net:tengj/gitStudy</span><br><span class="line"> * branch            dev        -&gt; FETCH_HEAD</span><br><span class="line">   b7b87f4..f636337  dev        -&gt; origin/dev</span><br><span class="line">Auto-merging a.txt</span><br><span class="line">CONFLICT (content): Merge conflict in a.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>先pull</li>
<li>再提交</li>
<li>解决冲突</li>
<li>push</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><hr>
<p>与分支相关的命令，大体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch           查看当前分支</span><br><span class="line">git branch -v        查看每一个分支的最后一次提交</span><br><span class="line">git branch -a        查看本地和远程分支的情况</span><br><span class="line">git branch --merged  查看已经与当前分支合并的分支</span><br><span class="line">git branch --no-merged 查看已经与当前分支未合并的分支</span><br><span class="line">git branch -r        查看远程分支</span><br><span class="line">git branch dev       创建分支 dev</span><br><span class="line">git checkout dev     切换到分支dev</span><br><span class="line">git checkout -b dev  创建并切换分支dev</span><br><span class="line">git merge dev        名称为dev的分支与当前分支合并</span><br><span class="line">git branch -d dev    删除分支dev</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="git-提交大文件"><a href="#git-提交大文件" class="headerlink" title="git  提交大文件"></a>git  提交大文件</h1><p>gitHub有大文件限制，超过100M拒绝提交。</p>
<p>官方提示使用<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">Git LFS</a>。(但是我在使用的过程中出现问题，使用无法push 到远程，可能是公司网络权限的问题。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">突破github限制，支持单个文件超出100M (使用 Git LFS)  Git LFS 全名为：Git Large File Storage</span><br><span class="line">Git LFS的官方网址在这里： https://git-lfs.github.com/</span><br><span class="line">现在来简单说下使用方式：先安装 Git LFS 的客户端，然后在将要push的仓库里重新打开一个bash命令行： </span><br><span class="line">只需设置1次 LFS : git lfs install</span><br><span class="line">然后 跟踪一下你要push的大文件的文件或指定文件类型 git lfs track &quot;*.pdf&quot; ， 当然还可以直接编辑.gitattributes文件</span><br><span class="line">以上已经设置完毕， 其余的工作就是按照正常的 add , commit , push 流程就可以了 : </span><br><span class="line">git add yourLargeFile.pdf</span><br><span class="line">git commit -m &quot;Add Large file&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line">备注： 我在push那本c++书的时候一些小细节：</span><br><span class="line">=============================================</span><br><span class="line">① 仓库从github上克隆时用的时HTTPS的方式，不是SSH(也可尝试使用这个，看下是否会成功)。 </span><br><span class="line">② 在最终push的时候会打印出如下信息： </span><br><span class="line">Git LFS: (0 of 0 files, 1 skipped) 0 B / 0 B, 147.30 MB skipped </span><br><span class="line">乍一看，表面上是跳过了该文件，但是回到github上查看，真的push上去了 </span><br><span class="line">③ 目前 Git LFS的总存储量为1G左右，超过需要付费。 </span><br><span class="line">====================================================</span><br><span class="line">使用中发现，必须先将.gitattributes文件进行更新、提交（Commit）和推送（Push），然后再对大文件进行Add，Commit，Push，即要分两次Push才能成功上传大文件。</span><br><span class="line"></span><br><span class="line">如果将.gitattributes的更新和大文件的Add，Commit，Push合并为一次Commit和Push，则Push依然会失败，提示不能上传大文件！</span><br></pre></td></tr></table></figure>

<p>在公司尝试失败，回家在自己电脑上再次尝试。</p>
<p>实验材料    <a href="https://u14797164.ctfile.com/fs/14797164-237162196" target="_blank" rel="noopener">https://u14797164.ctfile.com/fs/14797164-237162196</a></p>
<h1 id="git-只想clone-git仓库中的某一个文件而不是将整个仓库都克隆下来"><a href="#git-只想clone-git仓库中的某一个文件而不是将整个仓库都克隆下来" class="headerlink" title="git 只想clone git仓库中的某一个文件而不是将整个仓库都克隆下来"></a>git 只想clone git仓库中的某一个文件而不是将整个仓库都克隆下来</h1><h2 id="一：-使用工具网站"><a href="#一：-使用工具网站" class="headerlink" title="一： 使用工具网站"></a>一： 使用工具网站</h2><p><a href="http://downgit.zhoudaxiaa.com/" target="_blank" rel="noopener">DownGit</a>： 只需要找到仓库中对应文件夹的url,输入之后,点击 download 自动打包下载 (实验测试过可用且好用，但是这始终是别人的做的工具没有保障)</p>
<h2 id="二-：-仿照工具使用postman-或者下载工具发送请求"><a href="#二-：-仿照工具使用postman-或者下载工具发送请求" class="headerlink" title="二 ： 仿照工具使用postman 或者下载工具发送请求"></a>二 ： 仿照工具使用postman 或者下载工具发送请求</h2><p>需要下载地址： <a href="https://github.com/zhaodahan/zhao_Note/blob/master/%E5%BC%80%E5%8F%91.txt" target="_blank" rel="noopener">https://github.com/zhaodahan/zhao_Note/blob/master/%E5%BC%80%E5%8F%91.txt</a><br>参考地址：<a href="https://raw.githubusercontent.com/zhaodahan/English-level-up-tips-for-Chinese/master/word-list/Java.md" target="_blank" rel="noopener">https://raw.githubusercontent.com/zhaodahan/English-level-up-tips-for-Chinese/master/word-list/Java.md</a><br>生成下载地址：<a href="https://raw.githubusercontent.com/zhaodahan/zhao_Note/master/%E5%BC%80%E5%8F%91.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/zhaodahan/zhao_Note/master/%E5%BC%80%E5%8F%91.txt</a></p>
<p>(但是这样做存在问题，浏览器会默认的查看显示这个文件，而不是打包下载，还有一个致命的问题就是文件内容的中文编码，即使设置了请求头编码仍然存在显示问题)</p>
<h2 id="三：-克隆自己的项目"><a href="#三：-克隆自己的项目" class="headerlink" title="三： 克隆自己的项目"></a>三： 克隆自己的项目</h2><p>注意：本方法会下载整个项目，但是，最后出现在本地项目文件下里只有需要的那个文件夹存在。类似先下载，再过滤。有时候因为需要我们只想git clone 下仓库的单个或多个文件夹，而不是全部的仓库内容，这样就很省事。</p>
<p>在Git1.7.0以前，这无法实现，git认为如果这样做的话，仓库的数据一致性无法保证，但是幸运的是在Git1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。</p>
<p>举个例子：</p>
<p>现在有一个test仓库<a href="https://github.com/mygithub/test" target="_blank" rel="noopener">https://github.com/mygithub/test</a><br>你要gitclone里面的tt子目录：<br>在本地的硬盘位置打开Git Bash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init test &amp;&amp; cd test     //新建仓库并进入文件夹</span><br><span class="line">git config core.sparsecheckout true //设置允许克隆子目录</span><br><span class="line"></span><br><span class="line">echo &apos;tt*&apos; &gt;&gt; .git/info/sparse-checkout //设置要克隆的仓库的子目录路径   //空格别漏</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:mygithub/test.git  //这里换成你要克隆的项目和库</span><br><span class="line"></span><br><span class="line">git pull origin master    //下载</span><br></pre></td></tr></table></figure>



<h2 id="四-：解决的方法是用SVN"><a href="#四-：解决的方法是用SVN" class="headerlink" title="四 ：解决的方法是用SVN"></a>四 ：解决的方法是用SVN</h2><p>这个方法不用下载整个仓库，但是需要暗转SVN</p>
<p>下载TortoiseSVN。安装的时候记得把命令行勾上，默认不装。<br>假设我需要获取<a href="https://github.com/dynamsoft-dbr/cmake下的images目录。只需要用命令" target="_blank" rel="noopener">https://github.com/dynamsoft-dbr/cmake下的images目录。只需要用命令</a></p>
<p><code>svn export https://github.com/dynamsoft-dbr/cmake.git/trunk/images</code></p>
<p>就可以了。把trunk添加到仓库的链接后，然后加上子目录的路径。</p>
<h1 id="gitHub上某个仓库不想要了"><a href="#gitHub上某个仓库不想要了" class="headerlink" title="gitHub上某个仓库不想要了"></a>gitHub上某个仓库不想要了</h1><hr>
<p><img src="https://github.com/zhaodahan/zhao_Note/blob/master/wiki_img/github_delete.png?raw=true" alt="github_delete.png"></p>
<p>在做这步之前需要复制一下仓库名称，在删除确认的时候需要我们提供仓库名称(根据提示删除操作是无法撤销的，删除之前多思量)。</p>
<p><img src="https://github.com/zhaodahan/zhao_Note/blob/master/wiki_img/github_delete2.png?raw=true" alt="github_delete2.png"></p>
<hr>
<h1 id="git-分支对比"><a href="#git-分支对比" class="headerlink" title="git 分支对比"></a>git 分支对比</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有两个分支 dev 和主分支</span><br><span class="line"># 查看 dev 有，而 master 中没有的：</span><br><span class="line">$ git log dev ^master</span><br><span class="line"># 查看 dev 中比 master 中多提交了哪些内容：</span><br><span class="line">$ git log master..dev</span><br><span class="line"># 不知道谁提交的多谁提交的少，单纯想知道有什么不一样：</span><br><span class="line">git log dev...master</span><br><span class="line"># 在上述情况下，再显示出每个提交是在哪个分支上</span><br><span class="line">git log --left-right dev...master</span><br></pre></td></tr></table></figure>



<h1 id="git-提交忽略某些文件"><a href="#git-提交忽略某些文件" class="headerlink" title="git 提交忽略某些文件"></a>git 提交忽略某些文件</h1><p>在日常使用中，并非项目文件夹下的所有文件及文件夹变更都需要纳入版本控制。</p>
<h3 id="1、创建-gitignore文件"><a href="#1、创建-gitignore文件" class="headerlink" title="1、创建 .gitignore文件"></a>1、创建 .gitignore文件</h3><p>在git管理的项目文件夹中（严格的讲，应该叫做git的本地repository），创建一个文件名为“.gitignore”的纯文本文件<img src="https://images2015.cnblogs.com/blog/114186/201706/114186-20170623062535695-2077512996.png" alt="img"></p>
<p>上图中的.gitignore文件就是我用notepad++刚刚创建出来用于告诉git忽略哪些文件变更的配置文件。</p>
<p>Git在扫描文件变更时，会先查看.gitignore的配置，根据.gitignore中的配置再决定哪些文件需要被标注上untracked。当然，那些被ignore的文件肯定不会被标上untracked，因为那些文件对于git而言是透明的。</p>
<h3 id="2、编辑-gitignore文件"><a href="#2、编辑-gitignore文件" class="headerlink" title="2、编辑.gitignore文件"></a>2、编辑.gitignore文件</h3><p>编辑.gitignore文件，将target、nbactions.xml、nb-configuration.xml三个条目添加到.gitignore中，如<strong>列表1</strong>所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##############################</span><br><span class="line">## Folders                  ##</span><br><span class="line">##############################</span><br><span class="line">target</span><br><span class="line"> </span><br><span class="line">##############################</span><br><span class="line">## Netbeans conf            ##</span><br><span class="line">##############################</span><br><span class="line">nb-configuration.xml</span><br><span class="line">nbactions.xml</span><br></pre></td></tr></table></figure>

<p>上述我们不希望提交的文件变更全部消失了，git不会再追踪这些文件的变更情况，也不会将它们提交到服务器端。</p>
<h3 id="3、git-忽略失败"><a href="#3、git-忽略失败" class="headerlink" title="3、git 忽略失败"></a>3、git 忽略失败</h3><p>在项目中有些配置文件不需要提交，但是有同学在后面开发中发现在.igonore文件中无论如何都无法忽略某些文件的提交。原因在这里：</p>
<p> 已经维护起来的文件，即使加上了gitignore，也无济于事。—-</p>
<p>那么如何解决呢？方式如下</p>
<p><code>git update-index --assume-unchanged   要忽略的文件夹/文件夹下文件名</code></p>
<p>比如我要忽略项目下.idea文件夹下所有xml文件,idea下都是xml文件（我用的webstorm）：</p>
<p><code>git update-index --assume-unchanged   .idea/*.xml</code></p>
<p>如果要重新恢复提交，使用如下命令：</p>
<p><code>git update-index --assume-unchanged   .idea/*.xml</code></p>
<p>这样每次提交就不会提交idea下的文件了。</p>
<h1 id="git-看某次commit改了哪些文件"><a href="#git-看某次commit改了哪些文件" class="headerlink" title="git 看某次commit改了哪些文件"></a>git 看某次commit改了哪些文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log 查看commit的历史</span><br><span class="line">git show &lt;commit-hash-id&gt;查看某次commit的修改内容</span><br><span class="line">git log -p &lt;filename&gt;查看某个文件的修改历史</span><br><span class="line">git log -p -2查看最近2次的更新内容</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/21/git%20%E7%AC%94%E8%AE%B0/" data-id="ck20gx4l10000s8ilhjva34ax" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/10/21/git%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">git 问题解决记录</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/21/git%20%E7%AC%94%E8%AE%B0/">git 笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/21/git%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/">git 问题解决记录</a>
          </li>
        
          <li>
            <a href="/2019/10/21/%E6%B5%8B%E8%AF%95%E7%94%9F%E6%88%90%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">测试生成博客文章</a>
          </li>
        
          <li>
            <a href="/2019/10/21/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 zhaodahan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>